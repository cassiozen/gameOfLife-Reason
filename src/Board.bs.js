// Generated by BUCKLESCRIPT VERSION 2.0.0, PLEASE EDIT WITH CARE
'use strict';

import * as Curry      from "bs-platform/lib/es6/curry.js";
import * as Caml_array from "bs-platform/lib/es6/caml_array.js";
import * as Caml_int32 from "bs-platform/lib/es6/caml_int32.js";

function indexFor(param, board) {
  var col = param[1];
  var row = param[0];
  if (row < 0 || row >= board[/* height */1] || col < 0 || col >= board[/* width */0]) {
    return /* None */0;
  } else {
    return /* Some */[Caml_int32.imul(row, board[/* width */0]) + col | 0];
  }
}

function getCell(coords, board) {
  var index = indexFor(coords, board);
  if (index) {
    return Caml_array.caml_array_get(board[/* cells */2], index[0]);
  } else {
    return 0;
  }
}

function setCell(value, coords, board) {
  var index = indexFor(coords, board);
  if (index) {
    return Caml_array.caml_array_set(board[/* cells */2], index[0], value);
  } else {
    return /* () */0;
  }
}

function toggleCell(coords, board) {
  var index = indexFor(coords, board);
  if (index) {
    var i = index[0];
    return Caml_array.caml_array_set(board[/* cells */2], i, Caml_array.caml_array_get(board[/* cells */2], i) ? 0 : 1);
  } else {
    return /* () */0;
  }
}

function livingNeighbors(param, board) {
  var col = param[1];
  var row = param[0];
  return ((((((getCell(/* tuple */[
                          row - 1 | 0,
                          col - 1 | 0
                        ], board) + getCell(/* tuple */[
                          row - 1 | 0,
                          col
                        ], board) | 0) + getCell(/* tuple */[
                        row - 1 | 0,
                        col + 1 | 0
                      ], board) | 0) + getCell(/* tuple */[
                      row,
                      col - 1 | 0
                    ], board) | 0) + getCell(/* tuple */[
                    row,
                    col + 1 | 0
                  ], board) | 0) + getCell(/* tuple */[
                  row + 1 | 0,
                  col - 1 | 0
                ], board) | 0) + getCell(/* tuple */[
                row + 1 | 0,
                col
              ], board) | 0) + getCell(/* tuple */[
              row + 1 | 0,
              col + 1 | 0
            ], board) | 0;
}

function conwayRule(cellValue, livingNeighbors) {
  var isAlive = +(cellValue === 1);
  if (isAlive) {
    if (livingNeighbors === 2 || livingNeighbors === 3) {
      return 1;
    } else {
      return 0;
    }
  } else if (livingNeighbors === 3) {
    return 1;
  } else {
    return 0;
  }
}

function tick(present, future, $staropt$star, _) {
  var rule = $staropt$star ? $staropt$star[0] : conwayRule;
  for(var r = 0 ,r_finish = future[/* height */1]; r <= r_finish; ++r){
    for(var c = 0 ,c_finish = future[/* width */0]; c <= c_finish; ++c){
      var coords = /* tuple */[
        r,
        c
      ];
      var nextCell = Curry._2(rule, getCell(coords, present), livingNeighbors(coords, present));
      setCell(nextCell, coords, future);
    }
  }
  return future;
}

function make(param) {
  var h = param[1];
  var w = param[0];
  return /* record */[
          /* width */w,
          /* height */h,
          /* cells */Caml_array.caml_make_vect(Caml_int32.imul(w, h), 0)
        ];
}

var x = /* None */0;

export {
  x               ,
  indexFor        ,
  getCell         ,
  setCell         ,
  toggleCell      ,
  livingNeighbors ,
  conwayRule      ,
  tick            ,
  make            ,
  
}
/* No side effect */
